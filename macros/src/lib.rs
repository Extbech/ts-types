extern crate proc_macro;

use std::{fs::OpenOptions, path::Path};

use proc_macro::TokenStream;
use quote::quote;
use std::io::Write;
use syn::Data;

/// The `ts_type` attribute macro is designed to be applied to structs (and potentially enums in the future),
/// and it performs certain operations related to TypeScript type generation (or other uses).
///
/// ### Usage:
/// This macro does **not** accept any parameters. If any arguments are passed to the macro,
/// a compile-time error will be emitted.
///
/// ```rust
/// #[ts_type]
/// struct MyStruct {
///     field1: i32,
///     field2: String,
/// }
/// ```
///
/// ### Example of Invalid Usage:
/// Passing arguments to the macro will cause a compile-time error:
///
/// ```rust,compile_fail
/// #[ts_type("unexpected argument")]
/// struct AnotherStruct {
///     field1: i32,
///     field2: String,
/// }
/// ```
///
/// This will trigger a compile-time error with the message:
/// ```text
/// error: The ts_type attribute macro does not accept any arguments.
/// ```
///
#[proc_macro_attribute]
pub fn ts_type(args: TokenStream, item: TokenStream) -> TokenStream {
    // Handle Invalid args.
    // In this case it means any args.
    if !args.is_empty() {
        return quote! {
            compile_error!("The ts_type attribute macro does not accept any arguments.");
            struct _Dummy;
        }
        .into();
    }
    args.into_iter().for_each(|tree| println!("{:?}", tree));

    let my_cloned_item = item.clone();
    let input = syn::parse_macro_input!(my_cloned_item as syn::DeriveInput);
    let struct_identifier = &input.ident;
    let file_header = format!("/**\n * This file has been autogenerated by the `ts-types` Rust crate. Any Modifications are futile.\n */\n\n");
    println!("-------------------------------\n{}", struct_identifier);

    match &input.data {
        Data::Struct(syn::DataStruct { fields, .. }) => {
            let mut ts_fields = Vec::new();

            for field in fields {
                let identifier = field.ident.as_ref().unwrap().to_string();
                let ts_type = rust_type_to_ts_type(&field.ty);
                let ts_field = format!("\t{}: {};", identifier, ts_type);

                ts_fields.push(ts_field);
            }
            // Construct the full TypeScript type definition
            let file_name = format!("{}.ts", struct_identifier);
            let ts_type_string = format!(
                "{}export type {} = {{\n{}\n}};\n",
                file_header,
                struct_identifier,
                ts_fields.join("\n")
            );
            // Write the generated TypeScript to a .ts file
            write_ts_file(&file_name, &ts_type_string);
        }
        Data::Enum(_) => todo!("Implement Enum type gen"),
        _ => panic!("Unions not supported type"),
    }
    item
}

// Helper function to map Rust types to TypeScript types
fn rust_type_to_ts_type(ty: &syn::Type) -> proc_macro2::TokenStream {
    match ty {
        syn::Type::Path(type_path) => {
            let segment = type_path.path.segments.last().unwrap();
            match segment.ident.to_string().as_str() {
                "i32" | "i64" | "u32" | "u64" | "f32" | "f64" => quote! { number },
                "String" => quote! { string },
                "bool" => quote! { boolean },
                "Vec" => {
                    if let syn::PathArguments::AngleBracketed(args) = &segment.arguments {
                        if let Some(syn::GenericArgument::Type(inner_ty)) = args.args.first() {
                            let ts_inner_type = rust_type_to_ts_type(inner_ty); // Recursively map inner type
                            return quote! { Array<#ts_inner_type> };
                        }
                    }
                    return quote! { any };
                }
                _x => quote! { x },
            }
        }
        _x => quote! { x }, // Handle other cases, default to `any`
    }
}

// Helper function to write to a TypeScript file
fn write_ts_file(file_name: &str, content: &str) {
    let full_path = format!("./dump/{file_name}");
    let path = Path::new(&full_path);

    // Open the file in append mode, or create it if it doesn't exist
    let mut file = match OpenOptions::new()
        .write(true)
        .create(true)
        .truncate(true)
        .open(&path)
    {
        Ok(file) => file,
        Err(e) => panic!("Failed to open or create file: {}", e),
    };

    // Write the content to the file
    if let Err(e) = writeln!(file, "{}", content) {
        panic!("Failed to write to file: {}", e);
    }
}
